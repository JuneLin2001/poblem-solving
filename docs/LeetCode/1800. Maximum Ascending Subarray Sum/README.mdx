---
title: 1800. Maximum Ascending Subarray Sum
description: You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.
keywords: [LeetCode, 1800. Maximum Ascending Subarray Sum, Easy,Hash Table,String,Counting]
---

# [{frontMatter.title}](https://leetcode.com/problems/maximum-ascending-subarray-sum/)

:::danger Easy
:::

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
  <TabItem value="description" label="題目描述" default>
    ## Description


Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray `[numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi  < numsi+1.` Note that a subarray of size 1 is ascending.


#### Example 1:
Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.

#### Example 2:
Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.

#### Example 3:
Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
 

## Constraints:
```
1 <= nums.length <= 100
1 <= nums[i] <= 100
```

  </TabItem>
  <TabItem value="solution" label="解答">
   ## Solution
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxAscendingSum = function (nums) {
  let result = nums[0];
  let newResult = nums[0];

  for (i = 1; i < nums.length; i++) {
    if (nums[i] > nums[i - 1]) {
      result += nums[i];
    } else {
      newResult = Math.max(newResult, result);
      result = nums[i];
    }
  }

  return Math.max(newResult, result);
};

```
  </TabItem>
</Tabs>


## 解題思路
直接遍歷陣列暴力比較 i 有沒有比 i - 1 大，有的話就加上 i，如果碰壁的話就看之前累加的跟現在累加的哪個比較大並紀錄大的那個，並把碰壁的nums[i]當成新的起點繼續遍歷陣列
## 心得
一開始差了「把碰壁的nums[i]當成新的起點」所以邏輯有誤，解題完之後看整體發現其實比想像中的簡單。